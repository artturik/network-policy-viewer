// generated by tscriptify -package=k8s.io/api/networking/v1 -target=target_ts_file.ts networking/v1/types.go

export class ObjectMeta {
    name?: string;
    generateName?: string;
    namespace?: string;
    selfLink?: string;
    uid?: string;
    resourceVersion?: string;
    generation?: number;
    creationTimestamp?: Time;
    deletionTimestamp?: Time;
    deletionGracePeriodSeconds?: number;
    labels?: {[key: string]: string};
    annotations?: {[key: string]: string};
    ownerReferences?: OwnerReference[];
    finalizers?: string[];
    clusterName?: string;
    managedFields?: ManagedFieldsEntry[];

    static createFrom(source: any = {}) {
        return new ObjectMeta(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.name = source["name"];
        this.generateName = source["generateName"];
        this.namespace = source["namespace"];
        this.selfLink = source["selfLink"];
        this.uid = source["uid"];
        this.resourceVersion = source["resourceVersion"];
        this.generation = source["generation"];
        this.deletionGracePeriodSeconds = source["deletionGracePeriodSeconds"];
        this.labels = source["labels"];
        this.annotations = source["annotations"];
        this.finalizers = source["finalizers"];
        this.clusterName = source["clusterName"];
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}

export class NetworkPolicyEgressRule {
    ports?: NetworkPolicyPort[];
    to?: NetworkPolicyPeer[];

    static createFrom(source: any = {}) {
        return new NetworkPolicyEgressRule(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.ports = this.convertValues(source["ports"], NetworkPolicyPort);
        this.to = this.convertValues(source["to"], NetworkPolicyPeer);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class IPBlock {
    cidr: string;
    except?: string[];

    static createFrom(source: any = {}) {
        return new IPBlock(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.cidr = source["cidr"];
        this.except = source["except"];
    }
}
export class NetworkPolicyPeer {
    podSelector?: LabelSelector;
    namespaceSelector?: LabelSelector;
    ipBlock?: IPBlock;

    static createFrom(source: any = {}) {
        return new NetworkPolicyPeer(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.podSelector = this.convertValues(source["podSelector"], LabelSelector);
        this.namespaceSelector = this.convertValues(source["namespaceSelector"], LabelSelector);
        this.ipBlock = this.convertValues(source["ipBlock"], IPBlock);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class IntOrString {
    static createFrom(source: any = {}) {
        return new IntOrString(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
    }
}
export class NetworkPolicyPort {
    protocol?: string;
    port?: IntOrString;

    static createFrom(source: any = {}) {
        return new NetworkPolicyPort(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.protocol = source["protocol"] || 'TCP';
        this.port = this.convertValues(source["port"], IntOrString);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class NetworkPolicyIngressRule {
    ports?: NetworkPolicyPort[];
    from?: NetworkPolicyPeer[];

    static createFrom(source: any = {}) {
        return new NetworkPolicyIngressRule(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.ports = this.convertValues(source["ports"], NetworkPolicyPort);
        this.from = this.convertValues(source["from"], NetworkPolicyPeer);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class LabelSelectorRequirement {
    key: string;
    operator: string;
    values?: string[];

    static createFrom(source: any = {}) {
        return new LabelSelectorRequirement(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.key = source["key"];
        this.operator = source["operator"];
        this.values = source["values"];
    }
}
export class LabelSelector {
    matchLabels?: {[key: string]: string};
    matchExpressions?: LabelSelectorRequirement[];

    static createFrom(source: any = {}) {
        return new LabelSelector(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.matchLabels = source["matchLabels"];
        this.matchExpressions = this.convertValues(source["matchExpressions"], LabelSelectorRequirement);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class NetworkPolicySpec {
    podSelector: LabelSelector;
    ingress?: NetworkPolicyIngressRule[];
    egress?: NetworkPolicyEgressRule[];
    policyTypes?: string[];

    static createFrom(source: any = {}) {
        return new NetworkPolicySpec(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.podSelector = this.convertValues(source["podSelector"], LabelSelector);
        this.ingress = this.convertValues(source["ingress"], NetworkPolicyIngressRule);
        this.egress = this.convertValues(source["egress"], NetworkPolicyEgressRule);
        this.policyTypes = source["policyTypes"];
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class FieldsV1 {


    static createFrom(source: any = {}) {
        return new FieldsV1(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);

    }
}
export class ManagedFieldsEntry {
    manager?: string;
    operation?: string;
    apiVersion?: string;
    time?: Time;
    fieldsType?: string;
    fieldsV1?: FieldsV1;

    static createFrom(source: any = {}) {
        return new ManagedFieldsEntry(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.manager = source["manager"];
        this.operation = source["operation"];
        this.apiVersion = source["apiVersion"];
        this.time = this.convertValues(source["time"], Time);
        this.fieldsType = source["fieldsType"];
        this.fieldsV1 = this.convertValues(source["fieldsV1"], FieldsV1);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
export class OwnerReference {
    apiVersion: string;
    kind: string;
    name: string;
    uid: string;
    controller?: boolean;
    blockOwnerDeletion?: boolean;

    static createFrom(source: any = {}) {
        return new OwnerReference(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.apiVersion = source["apiVersion"];
        this.kind = source["kind"];
        this.name = source["name"];
        this.uid = source["uid"];
        this.controller = source["controller"];
        this.blockOwnerDeletion = source["blockOwnerDeletion"];
    }
}
export class Time {


    static createFrom(source: any = {}) {
        return new Time(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);

    }
}
export class NetworkPolicy {
    kind?: string;
    apiVersion?: string;
    metadata: ObjectMeta;
    ownerReferences?: OwnerReference[];
    managedFields?: ManagedFieldsEntry[];
    spec?: NetworkPolicySpec;

    static createFrom(source: any = {}) {
        return new NetworkPolicy(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.kind = source["kind"];
        this.apiVersion = source["apiVersion"];
        this.metadata = this.convertValues(source["metadata"], ObjectMeta);
        this.spec = this.convertValues(source["spec"], NetworkPolicySpec);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}

export class NetworkPolicyList {
    kind?: string;
    apiVersion?: string;
    selfLink?: string;
    resourceVersion?: string;
    continue?: string;
    remainingItemCount?: number;
    items: NetworkPolicy[];

    static createFrom(source: any = {}) {
        return new NetworkPolicyList(source);
    }

    constructor(source: any = {}) {
        if ('string' === typeof source) source = JSON.parse(source);
        this.kind = source["kind"];
        this.apiVersion = source["apiVersion"];
        this.selfLink = source["selfLink"];
        this.resourceVersion = source["resourceVersion"];
        this.continue = source["continue"];
        this.remainingItemCount = source["remainingItemCount"];
        this.items = this.convertValues(source["items"], NetworkPolicy);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
        if (!a) {
            return a;
        }
        if (a.slice) {
            return (a as any[]).map(elem => this.convertValues(elem, classs));
        } else if ("object" === typeof a) {
            if (asMap) {
                for (const key of Object.keys(a)) {
                    a[key] = new classs(a[key]);
                }
                return a;
            }
            return new classs(a);
        }
        return a;
    }
}
